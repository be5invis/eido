/*
	Language: Lofn
	Author: Belleve Invis
*/

hljs.LANGUAGES.moe = {
	process: function (entify) {
		var OPERATOR = 'operator',
			PUNCTOR = 'punctor',
			ID = 'identifier',
			NUMBER = 'number literal',
			STRING = 'string literal',
			COMMENT = 'comment',
			FLOWCTRL = 'keyword flowctrl',
			FUNCTION = 'keyword function',
			KEYWORD = 'keyword',
			LITERAL = 'literal',
			OPTION = 'preprocessor option';
		var nameTypes = {
		'is': OPERATOR, 'and': OPERATOR, 'not': OPERATOR, 'or': OPERATOR, 'in': OPERATOR,
		'as': OPERATOR, 'then': OPERATOR,
		'if': FLOWCTRL,
		'for': FLOWCTRL,
		'while': FLOWCTRL,
		'repeat': FLOWCTRL,
		'until': FLOWCTRL,
		'case': FLOWCTRL,
		'piecewise': FLOWCTRL,
		'when': FLOWCTRL,
		'function': FUNCTION,
		'return': FLOWCTRL,
		'throw': FLOWCTRL,
		'break': FLOWCTRL,
		'label': FLOWCTRL,
		'else': FLOWCTRL,
		'otherwise': FLOWCTRL,
		'var': KEYWORD,
		'def': KEYWORD,
		'this': KEYWORD,
		'true': LITERAL,
		'false': LITERAL,
		'null': LITERAL,
		'undefined': LITERAL,
		'fallthrough': KEYWORD,
		'arguments': KEYWORD,
		'callee': KEYWORD,
		'do': KEYWORD,
		'try': FLOWCTRL,
		'catch': FLOWCTRL,
		'finally': KEYWORD,
		'using': KEYWORD,
		'resend': KEYWORD,
		'new': KEYWORD,
		'wait': KEYWORD
	};
	var nameType = function (m) {
		if (nameTypes[m] > '')
			return nameTypes[m]
		else
			return ID
	};
	var symbolTypes = {
		'+': OPERATOR,
		'-': OPERATOR,
		'*': OPERATOR,
		'/': OPERATOR,
		'%': OPERATOR,
		'<': OPERATOR,
		'>': OPERATOR,
		'=': OPERATOR,
		'+=': OPERATOR,
		'-=': OPERATOR,
		'*=': OPERATOR,
		'/=': OPERATOR,
		'<<=': OPERATOR,
		'>>=': OPERATOR,
		'%=': OPERATOR,
		'<=': OPERATOR,
		'>=': OPERATOR,
		'<<': OPERATOR,
		'>>': OPERATOR,
		'<=>': OPERATOR,
		'==': OPERATOR,
		'!=': OPERATOR,
		'===': OPERATOR,
		'!==': OPERATOR,
		'=~': OPERATOR,
		'!~': OPERATOR,
		'->': OPERATOR,
		':>': OPERATOR,
		'=>': OPERATOR,
		'#': OPERATOR,
		'(': PUNCTOR,
		'[': PUNCTOR,
		'{': PUNCTOR,
		'}': PUNCTOR,
		']': PUNCTOR,
		')': PUNCTOR,
		',': PUNCTOR,
		':': PUNCTOR,
		'|': OPERATOR,
		'.': PUNCTOR,
		'..': OPERATOR,
		';': PUNCTOR,
		'@': OPERATOR,
		'\\': PUNCTOR,
		'!': OPERATOR
	};
	var symbolType = function (m) {
		if (symbolTypes[m] > '')
			return symbolTypes[m]
		else
			return PUNCTOR
	};
	var token_err = function(message, input, position){
		return new Error(message + ' at ' + position);
	}
	return function (input) {
		var make = function(t, v){
			return '<span class="' + t + '">' + v + '</span>'
		}
		var p_symbol = function (s) {
			return make(symbolType(s), entify(s));
		}
		return input.replace(
			(/(\/\/.*)|(?:^![ \t]*option[ \t]+(\w+)[ \t]*$)|([a-zA-Z_$][\w$]*)|((?:`[a-zA-Z_$][\w$]*)|(?:'[^']*(?:''[^']*)*')|(?:"[^\\"]*(?:\\.[^\\"]*)*"))|((?:0[xX][a-fA-F0-9]+)|(?:\d+(?:\.\d+(?:[eE]-?\d+)?)?))|([+\-*\/<>=!:%][<>=~]*|\.\.|[()\[\]\{\}|@\\;,\.#])/mg),
			function (match, comment, optionname, nme, string, number, symbol) {
				if (comment){
					if(match.slice(0, 3) === '//:'){
						return '<annotation id="' + match.slice(3) + '" />'
					} else
						return make(COMMENT, entify(match));
				} else if(optionname) {
					return make(OPTION, match);
				} if (nme) {
					return make(nameType(match), match)
				} else if (string) {
					return make(STRING, entify(match));
				} else if (number) {
					return make(NUMBER, match);
				} else if (symbol) {
					return p_symbol(match);
				} else {
					return match
				}
			});
		}
	}
}
