/*
Language: Javascript
Author: Belleve Invis
Category: common
*/

hljs.LANGUAGES.javascript = {
  process: function(entify){
	// EDIT: remove references to global to avoid namespace pollution

	// EDIT: add yielding op
	var IDENTIFIER = "identifier id",
		KEYWORD = "keyword reserved",
		NUMBER = "number",
		OPERATOR = "operator",
		PUNCTOR = "punctor",
		OPUNCTOR = "punctor open",
		CPUNCTOR = "punctor close",
		STRING = "string quote",
		REGEXP = "regexp quote",
		SEMICOLON = PUNCTOR + " SEMICOLON",
		ASSIGN = OPERATOR + " ASSIGN",
		NEWLINE = "newline",
		COMMENT = "comment",
		END = 0;

	var keywords = function(list){
		var obj = {};
		for(var i = 0; i < list.length; i += 1)
			obj[list[i]] = i + 1;
		return obj;
	}([
		 "break",
		 "case", "catch", "const", "continue",
		 "debugger", "default", "delete", "do",
		 "else", "enum",
		 "false", "finally", "for", "function",
		 "if", "in", "instanceof",
		 "new", "null",
		 "return",
		 "switch",
		 "this", "throw", "true", "try", "typeof",
		 "var", "void",
		 "while", "with" // EDIT: remove trailing comma (breaks IE)
	])

	// Operator and punctuator mapping from token to tree node type name.
	// NB: superstring tokens (e.g., ++) must come before their substring token
	// counterparts (+ in the example), so that the opRegExp regular expression
	// synthesized from this list makes the longest possible match.
	// EDIT: NB comment above indicates reliance on SpiderMonkey-specific
	//       behavior in the ordering of key iteration -- see EDIT below.
	// EDIT: add yeilding op
	var opTypeNames = {
		'\n': NEWLINE,
		';': SEMICOLON,
		',': PUNCTOR,
		'?': OPERATOR,
		':': OPERATOR,
		'||': OPERATOR,
		'&&': OPERATOR,
		'|': OPERATOR,
		'^': OPERATOR,
		'&': OPERATOR,
		'->': OPERATOR,
		'===': OPERATOR,
		'==': OPERATOR,
		'=': ASSIGN,
		'!==': OPERATOR,
		'!=': OPERATOR,
		'<<': OPERATOR,
		'<=': OPERATOR,
		'<': OPERATOR,
		'>>>': OPERATOR,
		'>>': OPERATOR,
		'>=': OPERATOR,
		'>': OPERATOR,
		'++': OPERATOR,
		'--': OPERATOR,
		'+': OPERATOR,
		'-': OPERATOR,
		'*': OPERATOR,
		'/': OPERATOR,
		'%': OPERATOR,
		'!': OPERATOR,
		'~': OPERATOR,
		'.': PUNCTOR,
		'[': OPUNCTOR,
		']': CPUNCTOR,
		'{': OPUNCTOR,
		'}': CPUNCTOR,
		'(': OPUNCTOR,
		')': CPUNCTOR
	};

	// EDIT: created separate opTypeOrder array to indicate the order in which
	//       to evaluate opTypeNames.  (Apparently, SpiderMonkey must iterate
	//       hash keys in the order in which they are defined, an implementation
	//       detail which the original narcissus code relied on.)
	// EDIT: add yielding op
	var opTypeOrder = [
		 '\n',
		 ';',
		 ',',
		 '?',
		 ':',
		 '||',
		 '&&',
		 '|',
		 '^',
		 '&',
		 '->',
		 '===',
		 '==',
		 '=',
		 '!==',
		 '!=',
		 '<<',
		 '<=',
		 '<',
		 '>>>',
		 '>>',
		 '>=',
		 '>',
		 '++',
		 '--',
		 '+',
		 '-',
		 '*',
		 '/',
		 '%',
		 '!',
		 '~',
		 '.',
		 '[',
		 ']',
		 '{',
		 '}',
		 '(',
		 ')'
	 ];

	var assignOps = ['|', '^', '&', '<<', '>>', '>>>', '+', '-', '*', '/', '%'];

	for (var i = 0, j = assignOps.length; i < j; i++) {
		opTypeNames[assignOps[i]] = ASSIGN;
	}

	/* vim: set sw=4 ts=8 et tw=80: */
	/* ***** BEGIN LICENSE BLOCK *****
	* Version: MPL 1.1/GPL 2.0/LGPL 2.1
	*
	* The contents of this file are subject to the Mozilla Public License Version
	* 1.1 (the "License"); you may not use this file except in compliance with
	* the License. You may obtain a copy of the License at
	* http://www.mozilla.org/MPL/
	*
	* Software distributed under the License is distributed on an "AS IS" basis,
	* WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
	* for the specific language governing rights and limitations under the
	* License.
	*
	* The Original Code is the Narcissus JavaScript engine.
	*
	* The Initial Developer of the Original Code is
	* Brendan Eich <brendan@mozilla.org>.
	* Portions created by the Initial Developer are Copyright (C) 2004
	* the Initial Developer. All Rights Reserved.
	*
	* Contributor(s):
	*
	* Alternatively, the contents of this file may be used under the terms of
	* either the GNU General Public License Version 2 or later (the "GPL"), or
	* the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
	* in which case the provisions of the GPL or the LGPL are applicable instead
	* of those above. If you wish to allow use of your version of this file only
	* under the terms of either the GPL or the LGPL, and not to allow others to
	* use your version of this file under the terms of the MPL, indicate your
	* decision by deleting the provisions above and replace them with the notice
	* and other provisions required by the GPL or the LGPL. If you do not delete
	* the provisions above, a recipient may use your version of this file under
	* the terms of any one of the MPL, the GPL or the LGPL.
	*
	* ***** END LICENSE BLOCK ***** */

	/*
	* Narcissus - JS implemented in JS.
	*
	* Lexical scanner and parser.
	*/


	// Build a regexp that recognizes operators and punctuators (except newline).
	var opRegExpSrc = "^(?:";

	// EDIT: change for loop from iterating through opTypeNames keys to using
	//       opTypeOrder array so that we're not dependent on SpiderMonkey's
	//       key order default behavior.
	// EDIT: change regex structure for OOM perf improvement
	for (var i = 0; i < opTypeOrder.length; i++) {
		var op = opTypeOrder[i];
		if (op == '\n')
			continue;
		if (opRegExpSrc != "^(?:")
			opRegExpSrc += "|";

		// EDIT: expand out this regexp for environments that don't support $&
		//opRegExpSrc += op.replace(/[?|^&(){}\[\]+\-*\/\.]/g, "\\$&");
		op = op.replace(/\?/g, "\\?");
		op = op.replace(/\|/g, "\\|");
		op = op.replace(/\^/g, "\\^");
		op = op.replace(/\&/g, "\\&");
		op = op.replace(/\(/g, "\\(");
		op = op.replace(/\)/g, "\\)");
		op = op.replace(/\{/g, "\\{");
		op = op.replace(/\}/g, "\\}");
		op = op.replace(/\[/g, "\\[");
		op = op.replace(/\]/g, "\\]");
		op = op.replace(/\+/g, "\\+");
		op = op.replace(/\-/g, "\\-");
		op = op.replace(/\*/g, "\\*");
		op = op.replace(/\//g, "\\/");
		op = op.replace(/\./g, "\\.");
		opRegExpSrc += op;
	}
	opRegExpSrc += ")";
	var opRegExp = new RegExp(opRegExpSrc);

	// A regexp to match floating point literals (but not integer literals).
	// EDIT: change regex structure for OOM perf improvement
	var fpRegExp = /^(?:\d+\.\d*(?:[eE][-+]?\d+)?|\d+(?:\.\d*)?[eE][-+]?\d+|\.\d+(?:[eE][-+]?\d+)?)/;

	function Tokenizer(s, f, l) {
		this.cursor = 0;
		this.source = String(s);
		this.tokens = [];
		this.tokenIndex = 0;
		this.lookahead = 0;
		this.scanNewlines = false;
		this.scanOperand = true;
		this.filename = f || "";
		this.lineno = l ? l : 1;
	}

	Tokenizer.prototype = {

		// EDIT: change "input" from a getter to a regular method for compatibility
		//       with older JavaScript versions
		input: function () {
			return this.source.substring(this.cursor);
		},

		get: function (annotQ, processIgnored, processGot, processAnnotation) {
			var token, type;

			for (; ; ) {
				var input = this.input();
				var firstChar = input.charCodeAt(0);
				// EDIT: check first char, then use regex
				// valid regex whitespace includes char codes: 9 10 11 12 13 32
				if (firstChar == 32 || (firstChar >= 9 && firstChar <= 13)) {
					var match = input.match(this.scanNewlines ? /^[ \t]+/ : /^\s+/); // EDIT: use x-browser regex syntax
					if (match) {
						var spaces = match[0];
						this.cursor += spaces.length;
						input = this.input();
						processIgnored(match[0]);
					}
				}

				// EDIT: improve perf by checking first string char before proceeding to regex,
				//       use x-browser regex syntax
				if (input.charCodeAt(0) != 47 || !(match = input.match(/^\/(?:\*(?:.|\r?\n)*?\*\/|\/.*)/)))
					break;
				var comment = match[0];
				this.cursor += comment.length;
				if(annotQ && (comment.slice(0, 3) === '//:')){
					processAnnotation(comment.slice(3).match(/\s*(\S+)/)[1])
				} else {
					processGot(COMMENT, comment);
				}
			}

			if (!input)
				return END;

			var firstChar = input.charCodeAt(0);

			// EDIT: guard by checking char codes before going to regex
			if ((firstChar == 46 || (firstChar > 47 && firstChar < 58)) &&
				 (match = input.match(fpRegExp))) { // EDIT: use x-browser regex syntax
				type = NUMBER;
				this.scanOperand = false;
			} else if ((firstChar > 47 && firstChar < 58) &&
						(match = input.match(/^(?:0[xX][\da-fA-F]+|0[0-7]*|\d+)/))) { // EDIT: change regex structure for OOM perf improvement,
				//       use x-browser regex syntax
				type = NUMBER;
				this.scanOperand = false;
			} else if (((firstChar > 47 && firstChar < 58) ||   // EDIT: add guards to check before using regex
						 (firstChar > 64 && firstChar < 91) ||
						 (firstChar > 96 && firstChar < 123) ||   // EDIT: exclude `
						 (firstChar == 36 || firstChar == 95)) && // EDIT: allow $ + mv _ here
						(match = input.match(/^[$\w]+/))) {       // EDIT: allow $, use x-browser regex syntax
				var id = match[0];
				// EDIT: check the type of the value in the keywords hash, as different envs
				//       expose implicit Object properties that SpiderMonkey does not.
				type = typeof (keywords[id]) == "number" ? KEYWORD : IDENTIFIER;
				this.scanOperand = (type === KEYWORD);
			} else if ((firstChar == 34 || firstChar == 39) &&
						(match = input.match(/^(?:"[^\\"]*(?:\\[\s\S][^\\"]*)*"|'[^\\']*(?:\\[\s\S][^\\']*)*')/))) { 
							// EDIT: change regex structure for OOM perf improvement,
				//       use x-browser regex syntax
				type = STRING;
				this.scanOperand = false;
			} else if (this.scanOperand && firstChar == 47 && // EDIT: improve perf by guarding with first char check
						(match = input.match(/^\/((?:\\.|\[(?:\\.|[^\\\]])+\]|[^\/\[\\])+)\/([gim]*)/))) { // EDIT: use x-browser regex syntax
							// EDIT: Changed for Character Groups. infinte.
				type = REGEXP;
			} else if ((match = input.match(opRegExp))) { // EDIT: use x-browser regex syntax
				type = opTypeNames[match[0]];
				this.scanOperand = (type != CPUNCTOR);
			} else {
				throw this.newSyntaxError("Illegal token : " + input.slice(0, 80));
			}

			this.cursor += match[0].length;
			processGot(type, match[0])
			return type;
		},

		newSyntaxError: function (m) {
			var e = new SyntaxError(m, this.filename, this.lineno);
			e.lineNumber = this.lineno; // EDIT: x-browser exception handling
			e.source = this.source;
			e.cursor = this.cursor;
			return e;
		}
	};

	return function(source, annotQ, annotV){
		var t = new Tokenizer(source);
		var v;
		var buffer = '';
		while(t.get(annotQ, 
					function(s){buffer += s}, 
					function(t, s){buffer += '<span class="' + t + '">' + entify(s) + '</span>'},
					function(id){buffer += '<annotation id="' + id + '" />'}));
		return buffer;
	}
  }
};
